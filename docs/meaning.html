<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta charset="utf-8" />
  
  <meta name="description" content="意味のコナーセンスは複数のコンポーネントが特定の値の意味に関して一致しなければならないときに生じます。" />
    <title>  コナーセンス(翻訳): 意味のコナーセンス
</title>

    <!-- Bootstrap -->
    <link href="./theme/css/bootstrap.min.css" rel="stylesheet">
    <link href="./theme/css/style.css" rel="stylesheet">
    <link href="./theme/css/pygments.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container-fluid">
      <div class="row contentrow">
        <div class="col-md-2 col-sm-4 col-xs-12">
          <div id="sidebar-wrapper">
            <div class="sidebar-brand">
              <h4><a href=".">コナーセンス(翻訳)</a></h4>
            </div>
            <div class="panel panel-default">
              <!-- Default panel contents -->
              <div class="panel-heading">静的なコナーセンス</div>
              <!-- List group -->
              <ul class="list-group">
                <li class="list-group-item"><a href="./name.html">名前</a></li>
                <li class="list-group-item"><a href="./type.html">型</a></li>
                <li class="list-group-item"><a href="./meaning.html">意味</a></li>
                <li class="list-group-item"><a href="./position.html">位置</a></li>
                <li class="list-group-item"><a href="./algorithm.html">アルゴリズム</a></li>
              </ul>
              <!-- Default panel contents -->
              <div class="panel-heading">動的なコナーセンス</div>
              <!-- List group -->
              <ul class="list-group">
                <li class="list-group-item"><a href="./execution.html">実行</a></li>
                <li class="list-group-item"><a href="./timing.html">タイミング</a></li>
                <li class="list-group-item"><a href="./value.html">値</a></li>
                <li class="list-group-item"><a href="./identity.html">同一性</a></li>
              </ul>
              <!-- Default panel contents -->
              <div class="panel-heading">プロパティ</div>
              <!-- List group -->
              <ul class="list-group">
                <li class="list-group-item"><a href="./strength.html">強度</a></li>
                <li class="list-group-item"><a href="./locality.html">局所性</a></li>
                <li class="list-group-item"><a href="./degree.html">程度</a></li>
              </ul>
              <div class="panel-heading"><a href="./pages/about.html">About</a></div>
            </div>
          </div> <!-- sidebar-wrapper -->
        </div>

        <div class="col-md-10 col-sm-8 col-xs-12">
          <div id="page-content-wrapper">
            <div class="container-fluid">
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="./meaning.html" rel="bookmark"
         title="Permalink to 意味のコナーセンス">意味のコナーセンス</a></h2>
 
  </header>
  <div class="entry-content">
    <!-- Connascence of meaning is when multiple components must agree on the meaning of particular values. Consider some code that processes credit card payments. The following function might be used to determine if a given credit card number is valid or not: -->
<p>意味のコナーセンスは複数のコンポーネントが特定の値の意味に関して一致しなければならないときに生じます。クレジットカード決済を処理するコードを考えてみます。以下の関数はクレジットカード番号が有効かどうかを判定するためのものです。</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_credit_card_number_valid</span><span class="p">(</span><span class="n">card_number</span><span class="p">):</span>
    <span class="c1"># Check for &#39;test&#39; credit card numbers:</span>
    <span class="k">if</span> <span class="n">card_number</span> <span class="o">==</span> <span class="s2">&quot;9999-9999-9999-9999&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="c1"># Do normal validation:</span>
    <span class="c1"># ...</span>
</pre></div>
<!-- The problem here is that all parts of this system must agree that ``9999-9999-9999-9999`` is the test credit card number. If that value changes in one place, it must also change in another. -->
<p>ここで問題になるのは、このシステムの全体に渡って <tt class="docutils literal"><span class="pre">9999-9999-9999-9999</span></tt> がテスト用のカード番号であるという点で一致しなければならないということです。この値が一箇所で変更されれば、他の箇所でも変更する必要があります。</p>
<!-- Here's another example where user roles are encoded as integers: -->
<p>他の例を挙げます。ユーザーのロールが以下のように整数でエンコードされているとします。</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_user_role</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="n">get_user_object_for_username</span><span class="p">(</span><span class="n">username</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">is_admin</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">user</span><span class="o">.</span><span class="n">is_manager</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
</pre></div>
<!-- Elsewhere, code might need to check that a given username is an administrator, like so: -->
<p>別の場所で、与えられたユーザー名が管理者権限を持つかどうかを確認する必要があるかもしれません。</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">get_user_role</span><span class="p">(</span><span class="n">username</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">PermissionDenied</span><span class="p">(</span><span class="s2">&quot;You must be an administrator&quot;</span><span class="p">)</span>
</pre></div>
<!-- Connascence of meaning can be improved to connascence of name by moving the "magic values" to named constants, and referring to the constants instead of the values. However in doing so, we have increased the amount of connascence of name (since we now need a third location to store the constant). -->
<p>「マジックバリュー」を名前付き定数に移動し、値の代わりに定数を参照するようにすれば、意味のコナーセンスは名前のコナーセンスへと改善できます。しかしそうしたとしても、名前のコナーセンスの量は増えます（定数を保存するためにまた別の場所を必要とするからです）。</p>
<!-- Another common example of connascence of meaning is when ``None`` is used as a return value. This frequently occurs in functions that are tasked with finding an object. If that object isn't found, the function might return ``None``. -->
<p>他のよくある例は、<tt class="docutils literal">None</tt> が返り値として使われる場合です。これは何らかのオブジェクトを見つけるタスクを実行する関数でよく起こります。オブジェクトが見つからなければ <tt class="docutils literal">None</tt> を返すというわけです。</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_user_in_database</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">database</span><span class="o">.</span><span class="n">find_user</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">username</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span>
</pre></div>
<!-- However, the function might also return None in an error condition: -->
<p>しかし、この関数はエラーが起きたときにも None を返すかもしれません。</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_user_in_database</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">database</span><span class="o">.</span><span class="n">find_user</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">username</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span>
    <span class="k">except</span> <span class="n">DatabaseError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
</pre></div>
<!-- The problem in both these cases is that a semantic meaning is being assigned to the ``None`` value. If multiple different meanings are assigned to the same ``None`` value in the same codebase, the programmer must remember which meaning applies to which case. This can be improved to connascence of name by returning an explicit object that represents the case in question: -->
<p>この両ケースで問題なのは、セマンティックな意味が <tt class="docutils literal">None</tt> の値に割り当てられていることです。一つのコードベース内で同じ <tt class="docutils literal">None</tt> が複数の異なる意味を持っていると、プログラマーがどの場合にどの意味になっているかを覚えておかなければならなくなります。これは当該の状態を明示的に表すオブジェクトを返すようにすることで、名前のコナーセンスへと改善できます。</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_user_in_database</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">database</span><span class="o">.</span><span class="n">find_user</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">username</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ObjectNotFound</span>
    <span class="k">except</span> <span class="n">DatabaseError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
</pre></div>
<!-- We still have connascence of meaning in the error case, but at least the ``None`` value is no longer ambigous. The error case could also be improved to connascence of name in a similar way. -->
<p>エラー発生時の処理に意味のコナーセンスがまだ残っていますが、少なくとも <tt class="docutils literal">None</tt> の値は曖昧でなくなりました。エラー発生時の処理も同じようなやり方で名前のコナーセンスに改善できます。</p>
<!-- Another common example of connascence of meaning is when we use primitive numeric types to represent more complex values. Consider this line of code in a codebase that processes payments: -->
<p>さらに他のよくある例は、プリミティブな数値型で複雑な値を表現しようとする場合です。決済を処理するコードベースの中にあるこんな行を考えてみてください。</p>
<div class="highlight"><pre><span></span><span class="n">unit_cost</span> <span class="o">=</span> <span class="mf">49.95</span>
</pre></div>
<!-- What currency is that cost expressed in? US dollars? British pounds? How do you ensure that two costs with different currencies are not added together? Similar to the examples above, the problem is that a semantic meaning is being added to the primitive type. It can be improved to connascence of type by creating a 'Cost' type that disallows operations between different currencies: -->
<p>コストはどの通貨で表現されているのでしょうか。米ドルでしょうか、それとも英ポンドでしょうか。通貨が異なる場合はコストを足し合わせられないことをどのように保証できるでしょうか。今までの例と同じように、問題はセマンティックな意味がプリミティブ型に与えられていることです。'Cost' 型を作成して異なる通貨間の操作をできないようにすれば、これは型のコナーセンスに改善できます。</p>
<div class="highlight"><pre><span></span><span class="n">unit_cost</span> <span class="o">=</span> <span class="n">Cost</span><span class="p">(</span><span class="mf">49.95</span><span class="p">,</span> <span class="s1">&#39;USD&#39;</span><span class="p">)</span>
</pre></div>
<!-- This particular problem is often called "**Primitive Obsession**", and can be generically described as using primitive data types to represent more complex domains. -->
<p>特にこの問題は「<strong>プリミティブ型への執着</strong>」と呼ばれることがあり、プリミティブデータ型で複雑なドメインを表現しようとする問題として一般に知られています。</p>

  </div><!-- /.entry-content -->
</section>
            </div>
          </div>
        </div>
      </div>
    </div>
    <footer class="footer">
      <div class="container">
        <p class="text-muted"><a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/80x15.png" /></a>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.</p>
      </div>
    </footer>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="./theme/js/bootstrap.min.js"></script>
    <script>
      // (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      //   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      //   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      // })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      // ga('create', 'UA-66884952-1', 'auto');
      // ga('send', 'pageview');
    </script>
  </body>
</html>